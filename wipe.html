<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>擦</title>
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="apple-mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="black"/>
  <meta name="format-detection" content="telephone=no"/>
  <meta name="format-detection" content="email=no"/>
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0"/>
  <style>
    html, body {
      padding: 0;
      margin: 0;
      overflow: hidden;
    }

    .page {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .index {
      background: url("./bg.png") no-repeat top center;
      background-size: cover;
    }

    canvas {
      /*background: url("./1.jpg") no-repeat 0 0;*/
    }
  </style>
</head>
<body>
<div class="pages">
  <div class="page index"></div>
</div>
<script>
var clientWidth = document.documentElement.clientWidth
var clientHeight = document.documentElement.clientHeight
var canvas = document.createElement('canvas')
document.body.appendChild(canvas)
var canvasWidth = canvas.width = clientWidth
var canvasHeight = canvas.height = clientHeight
var ctx = canvas.getContext('2d')
globalCompositeOperation = 'source-over' // 解决部分手机白屏问题
// ctx.fillStyle = 'grey';
// ctx.fillRect(0, 0, canvas.width, canvas.height);
var image = new Image();
image.onload = function() {
  var ratio = image.height / canvas.height
  var drawImageWidth = image.width / ratio
  ctx.drawImage(image, -(drawImageWidth - canvas.width) / 2, 0, drawImageWidth, canvas.height);
  initPen();
  // for (var i = 0; i < 10; i++) {
  // ctx.moveTo(Math.random() * canvas.width, Math.random() * canvas.height);
  //   ctx.lineTo(Math.random() * canvas.width, Math.random() * canvas.height)
  // }
  // ctx.stroke();
  forceRepaint(canvas);
}
image.src = './mask.png';

function initPen() {
  ctx.globalCompositeOperation = 'destination-out'
  ctx.lineWidth = '30'
  ctx.lineCap = 'round'
  ctx.lineJoin = 'round'
  ctx.beginPath();
}

document.addEventListener('touchstart', function(e) {
  var touch = e.changedTouches[0]
  ctx.moveTo(touch.clientX, touch.clientY);
}, false);

document.addEventListener('touchmove', function(e) {
  e.preventDefault();
  var touch = e.changedTouches[0]
  ctx.lineTo(touch.clientX, touch.clientY);
  ctx.stroke();
  // forceRepaint(canvas);
}, false);

document.addEventListener('touchend', function(e) {
  if (checkScrapeFinished()) {
    endScrape();
  }
}, false);

function forceRepaint(elem) {
  if (!elem.style.opacity) {
    elem.style.opacity = 0.999;
  } else {
    elem.style.opacity = '';
  }

  elem.style.display='none';
  elem.offsetHeight;
  elem.style.display='block';
}

function checkScrapeFinished() {
  var pixels = 0
  var clearedPixels = 0

  var left1 = canvasWidth * 0.156
  var top1 = left1 * 1.16
  var width1 = canvasWidth * 0.412
  var height1 = width1 * 1.234

  var left2 = canvasWidth * 0.696
  var top2 = left2 * 0.354
  var width2 = canvasWidth * 0.271
  var height2 = width2 * 1.747

  calcPixels(left1, top1, width1, height1);
  calcPixels(left2, top2, width2, height2);

  function calcPixels(left, top, width, height) {
    var data = ctx.getImageData(left, top, width, height).data;

    for (var i = 0; i < data.length; i += 4) {
      pixels++;
      if (data[i + 3] == 0) clearedPixels++;
    }
  }

  return clearedPixels / pixels > 0.7
}

function checkRegion(touch) {
  // 检查是否在刮的区域内
  return (touch.clientX > region.left && touch.clientX < region.right &&
    touch.clientY > region.top && touch.clientY < region.bottom);
}

function checkElements() {
  var elements = wrap.querySelectorAll('.active-el'),
    pixels = 0,
    clearedPixels = 0,
    rect, left, top, width, height;

  if (elements.length === 0) {
    elements = wrap.querySelectorAll('*');
  }

  for (var j = 0; j < elements.length; j++) {
    rect = elements[j].getClientRects()[0];
    if (!rect) continue;
    left = rect.left - region.left;
    top = rect.top - region.top;
    width = rect.right - rect.left;
    height = rect.bottom - rect.top;
    data = context.getImageData(left, top, width, height).data;

    for (var i = 0; i < data.length; i += 4) {
      pixels++;
      if (data[i + 3] == 0) clearedPixels++;
    }
  }

  return clearedPixels / pixels;
}

function endScrape() {
  canvas.style.webkitTransition = 'opacity 0.6s ease';
  canvas.style.opacity = 0;
  setTimeout(function() {
    canvas.style.display = 'none';
    // opt.onfinish && opt.onfinish();
  }, 600);
}
</script>
</body>
</html>